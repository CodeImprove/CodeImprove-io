<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodeImpove: Program Adaptation for Deep Code Models</title>
</head>
<body>
    <header>
        <h1>CodeImprove: Program Adaptation for Deep Code Models </h1>
    </header>
</body>

<section class="section">
  <div class="container is-max-desktop">
    <!-- Abstract. -->
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <h2 class="title is-3">Abstract</h2>
        <div class="content has-text-justified">
          <p>
            Leveraging deep learning (DL)-based code analysis tools to solve software engineering tasks is becoming increasingly popular. However, these tools face challenges related to
performance limitations, scalability issues, and the potential for erroneous results (i.e., mispredictions). Retraining is often required to address these issues, but frequent model updates
are costly in labeling and deployment. In this paper, we explore an alternative solution: Adapting the program inputs to the
code models. This can be achieved by two steps: 1) input validation that focuses on identifying whether an input is an out-of-scope input program that are beyond a model’s handling
capability, and 2) input adaptation that adapts out-of-scope inputs to become in-scope inputs. Validating program input is challenging, as current techniques focus on continuous inputs such as image data and fail with discrete inputs like code data, which have unique characteristics and are processed differently by deep learning models. Adapting out-of-scope programs is also challenging due to their vast search spaces. Therefore, in
this paper, we propose CodeImprove, which distinguishes out-of-scope from normal inputs and converts such out-of-scope
inputs back to in-scope inputs through program transformation.
In particular, we propose a validity score metric to identify out-of-scope inputs and leverage genetics algorithms to apply semantic preserving program transformation to convert out-of-scope inputs to in-scope inputs. Our experimental results show CodeImprove can enhance upto 8.78% of accuracy, and 51.28% of relative improvements in three code models on two SE tasks.
Additionally, our input validation is promising in detecting out-of-scope inputs (AUC score of 0.924).
          </p>
        </div>
      </div>
    </div>
    <!--/ Abstract. -->

 <!-- Paper Photo. -->
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <h2 class="title is-3">Overview</h2>
        <div class="publication-overview">
            <style>
                figure {
                  max-width: 600px;
                  max-height: 200px;
                  border: 1px #cccccc solid;
                  padding: 4px;
                  margin: auto;
                }

                figcaption {
                  background-color: black;
                  color: white;
                  font-style: italic;
                  padding: 2px;
                  text-align: center;
                }
         </style>
            
        <figure> 
          <img src="./Figures/Overview.jpg" alt="Overview" width="650" height="200"> 
           <figcaption>Figure 1. Overview of CodeImprove</figcaption>
        </figure>
                <p> <br><br><br> Figure 1. shows the overview of <b>CodeImprove</b>. CodeImprove consists of two main technical phases: <i>Input Validation</i> phase to detect out-of-scope inputs from normal inputs, and <i>Input Adaptation </i> phase to transform out-of-scope inputs to in-scope
                    inputs. </p>
        </div>
      </div>
    </div>
    <!--/ Paper overview. -->
  </div>
</section>

     <!--/ Problem Definition -->
<body>
    <h1>Problem Definition</h1>
    
    <section id="problem-definition">
        <h2>Oracle Problem and Code Adaptation</h2>
        <p>
            Given a code model \( M \) and an input code snippet \( x \), the class with the largest probability is the final prediction result of \( M \) for \( x \), denoted as \( M(x) \). Assume \( y \) is the ground truth label of \( x \). We can denote the correct prediction or misprediction as follows:
        </p>
        <ul>
            <li>If \( y == M(x) \), it is a correct prediction.</li>
            <li>Else, it is a misprediction.</li>
        </ul>
        <p>
            However, these code models do not guarantee the correct prediction for each test input during deployment. This work aims to improve the model performance on test inputs via code adaptation, which is an effective technique different from others that require retraining or replacing the model.
        </p>
        <p>
            During the deployment of a code model, we cannot exactly determine whether the prediction for a given code input is correct without manual analysis. This means that it is difficult to automatically decide whether a given code input is correctly predicted or not. Therefore, we can formulate the oracle problem as follows:
        </p>
        <p>
            For a code model \( M \) and an input code snippet \( x \), let \( V \) be the metric that determines the validation of the input \( x \). Hence:
        </p>
        <ul>
            <li>If \( V(M(x)) > c \), it is a correct prediction, where \( c \) is a threshold to differentiate the validity score.</li>
            <li>Else, it is a misprediction.</li>
        </ul>
        <p>
            For each mispredicted input, we can apply a sequence of transformations to find the most likely input to adapt the model’s performance. Assume that \( T \) is the algorithm to apply a set of transformations \( T_1, T_2, T_3, \ldots, T_n \) to find a new input \( x' \). We predict the new input \( x' \) with \( M \) to get \( y' \):
        </p>
        <p>
            \( x' = T(T_1, T_2, \ldots, T_n(x)) \)<br>
            \( y' = M(x') \)<br>
            If \( y' == y \), adapt the input.<br>
            Else, apply more transformations.
        </p>
    </section>
</body>

    
<section class="section">
  <div class="container is-max-desktop">
    <!-- Rules -->
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <h2 class="title is-3">Transformation Rules </h2>
        <div class="content has-text-justified">
            <ol type="1">
                <p> CodeImprove currently employs 15 transformation operators. The list of operators are as follows: <br><br></p>
              <li>Function and Variable Name Renaming</li>
                    <p>
                        We will extract all identifiers from a given input by parsing the code and capturing the identifiers by filtering out keywords, macros, and special identifiers (e.g., main, stdio, etc.). This step ensures that the identifiers are only variable/function names. 
                        <br>
                        Next, the process of renaming identifiers involves two steps: identifying and subsituting the most important identifier. 
                        
                        <br> Our approach is focused on obtaining the logit outputs by the target model for supervision. 
                        We introduce a metric called the importance score. 
                        To compute the importance score we retrieved the tokens of both original code C = [t<sub>0</sub>, · · ·, t<sub>i</sub>, · · ·] and code after replacing the identifier with [MASK] at the i<sup>th</sup> token C<sub>i</sub> = [t<sub>0</sub>, · ·, t<sub>i-1</sub>, [MASK], t<sub>i+1</sub>, · · ·]. 
                        The logit output of C and C<sub>i</sub> denoted as O<sub>y</sub>(C) and O<sub>y</sub>(C<sub>i</sub>) respectively. 
                        
                        The importance score is denoted as: <br> <br>
                        I<sub>i</sub> = O<sub>y</sub>(C) − O<sub>y</sub>(C<sub>i</sub>) <br><br>


                        Once the importance scores are computed, we select the top K identifiers. For each identifier in K we replace the original
                        identifier by generating candidates using the RoBERTa masked language model. Then we selected the identifier with highest logit output value to replace the original code. 
                        Maintaining K identifiers ensure to limit the large search space because the search space is limited to K identifiers.

                        <pre><code>
                            int i; to int t; 
                        </code></pre>

                        
                    </p>
                
              <li>for-loop to while-loop. <br>
            <pre>
            <code>
            For-loop:
                for (initialization; condition; increment) {
                // Loop body
                // Statements to execute
                }

            While-loop Transformation:
                initialization
                while (condition) {
                    // Loop body
                    // Statements to execute
                    increment;
                }
              </code>
              </pre>
              <br></li>
              <li>while-loop to for-loop. <br><br>
               <pre>
               <code>
            While-loop:
                while (condition) {
                        // Loop body
                        // Statements to execute
                        increment;
                }

            For-loop Transformation:
                for(initialization; condition; increment) {
                    // Loop body
                    // Statements to execute
                }
                </code>
                </pre>  </li>
              <li>do-loop to while-loop. <br> 
                    <p>During do-while-loop transformation into a while-loop, the body statement inside the do-while-loop
                    will be executed once before entering the transformed
                    while-loop. </p>
              <pre>
              <code>
               Do-while-loop:
                    do {
                        // Loop body
                        // Statements to execute
                        increment;
                    } while (condition);

                While-loop Transformation:
                        // Execute the loop body
                        // Statements to execute
                        while (condition) {
                        // Loop body
                        // Statements to execute
                        increment;
                    }
                    </code>
                    </pre>
              
              
              
              
              </li>
              <li>if elseif to if else <br>
              <pre>
              <code>
               if else-if :
                    if(condition A){ 
                          //body A
                    }else-if (condition B){
                          //body B
                    } else {
                          //body C
                    }

                if-else transformation:
                    if(condition A){ 
                          //body A
                    } else {
                         if (condition B) {
                            //body B
                         }
                         else {
                            //body C
                          }
                     } 
                    </code>
                    </pre>
              </li>
              <li>if else to if else-if <br> 
              <pre>
              <code>

                  if-else:
                    if(condition A){ 
                          //body A
                    } else {
                         if (condition B) {
                            //body B
                         }
                         else {
                            //body C
                          }
                     } 

                    if else-if transformation:
                      if(condition A){ 
                          //body A
                        }else-if (condition B){
                          //body B
                        } else {
                          //body C
                        }
              </code>
              </pre>
              </li>
                  
              <li>Switch statements to if elseif <br> <pre><code>
                <pre>
              <code>
                  switch statement:
                      switch (a) {
                        case A: body A
                        case B: body B
                        default: body C
                     }

                  if else-if transformation: 
                      if (a ==A) body A
                      else if (a==B) body B
                      else body C 
             
              </code>
               </pre>
              </li>
              
                    
                  
              <li>Relation expression transformation. <br>
               Transform relational expressions such as <pre><code> a < b to b >a </b></code></pre>
              
              </li>
              <li>Modification to Unary operations. <br> 
              Modify unary operations such as <pre><code> i++; to i=i+1;</code></pre>
              
              </li>
              <li>Modifications to incremental operations. <br>
              Modifies incremental operators such as <pre><code> i+=1; to i=i+1;</code></pre>
              
              </li>
              <li>Modifying constants <br> 
              Modify the constant values in expressions such as <pre><code> i = 0; to i = 10-10;</code></pre>
              
              </li>
              <li>Modifications to variable definitions. <br>
              Modifies the definitions of variables. <pre><code> 
              int b = 0; to int b; b=0;
              </code></pre>
              
              </li>
              <li>Add junk code. <br>
              <p>Adds code that will never be executed</p>
                  <pre><code>
                      before adding the junk code: 
                          if(a){
                              \\body A
                          }

                      after adding the junk code:
                          if(a){
                              \\body A
                              if (0) return 0;
                          }


                  </code></pre>
              </li>
              <li>Change order of statements in a block. <br>
                 <p> Only reorder the statements without any data- or control-dependency.</p>

                  <pre><code>
                    before reorder: 
                      a = b+10;
                      c = d+10;

                    after reorder:
                      c = d+10;
                      a = b+10;

                      
                  </code></pre>
              
              
              </li>
              <li>Deleting statements that print debugging hints and comments. <br>
                <p>Only delete comments or statements that print debugging hints or intermediate results.</p>
                 <pre><code>
                        printf("trial");
                        //comments;


                         to 

                          <strike>printf("trial); </strike>
                          <strike> //comments;  </strike>
                    

                     
                 </code></pre>
                  
              </li>

            </ol>  
     </div>
      </div>
    </div>
    <!--/ Paper overview. -->
  </div>
</section>

    
</html>
