<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodeImpove: Program Adaptation for Deep Code Models</title>

    <style>
        body {
            font-family: Arial, sans-serif;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        table, th, td {
            border: 1px solid black;
        }
        th, td {
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #f2f2f2;
        }
        thead th {
            border-bottom: 2px solid black;
        }
        tbody tr:not(:last-child) {
            border-bottom: 1px solid black;
        }
        caption {
            caption-side: top;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .container {
            display: flex;
            justify-content: space-between;
        }
        .figure {
            background-color: #fff;
            padding: 20px;
            margin: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            width: 45%;
        }
        .figure img {
            max-width: 75%;
            height: auto;
        }
        .caption {
            text-align: center;
            margin-top: 10px;
        }
        code {
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            color: #333;
            background-color: #f9f9f9;
            padding: 5px;
            border-radius: 5px;
        }
        .section-caption {
            text-align: center;
            margin: 20px 0;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <header>
        <h1>CodeImprove: Program Adaptation for Deep Code Models </h1>
    </header>
</body>

<section class="section">
  <div class="container is-max-desktop">
    <!-- Abstract. -->
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <h2 class="title is-3">Abstract</h2>
        <div class="content has-text-justified">
          <p>
            Leveraging deep learning (DL)-based code analysis tools to solve software engineering tasks is becoming increasingly popular. However, these tools face challenges related to
performance limitations, scalability issues, and the potential for erroneous results (i.e., mispredictions). Retraining is often required to address these issues, but frequent model updates
are costly in labeling and deployment. In this paper, we explore an alternative solution: Adapting the program inputs to the
code models. This can be achieved by two steps: 1) input validation that focuses on identifying whether an input is an out-of-scope input program that are beyond a model’s handling
capability, and 2) input adaptation that adapts out-of-scope inputs to become in-scope inputs. Validating program input is challenging, as current techniques focus on continuous inputs such as image data and fail with discrete inputs like code data, which have unique characteristics and are processed differently by deep learning models. Adapting out-of-scope programs is also challenging due to their vast search spaces. Therefore, in
this paper, we propose CodeImprove, which distinguishes out-of-scope from normal inputs and converts such out-of-scope
inputs back to in-scope inputs through program transformation.
In particular, we propose a validity score metric to identify out-of-scope inputs and leverage genetics algorithms to apply semantic preserving program transformation to convert out-of-scope inputs to in-scope inputs. Our experimental results show CodeImprove can enhance upto 8.78% of accuracy, and 51.28% of relative improvements in three code models on two SE tasks.
Additionally, our input validation is promising in detecting out-of-scope inputs (AUC score of 0.924).
          </p>
        </div>
      </div>
    </div>
    <!--/ Abstract. -->

 <!-- Paper Photo. -->
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <h2 class="title is-3">Overview</h2>
        <div class="publication-overview">
            <style>
                figure {
                  max-width: 600px;
                  max-height: 200px;
                  border: 1px #cccccc solid;
                  padding: 4px;
                  margin: auto;
                }

                figcaption {
                  background-color: black;
                  color: white;
                  font-style: italic;
                  padding: 2px;
                  text-align: center;
                }
         </style>
            
        <figure> 
          <img src="./Figures/Overview.jpg" alt="Overview" width="650" height="200"> 
           <figcaption>Figure 1. Overview of CodeImprove</figcaption>
        </figure>
                <p> <br><br><br> Figure 1. shows the overview of <b>CodeImprove</b>. CodeImprove consists of two main technical phases: <i>Input Validation</i> phase to detect out-of-scope inputs from normal inputs, and <i>Input Adaptation </i> phase to transform out-of-scope inputs to in-scope
                    inputs. </p>
        </div>
      </div>
    </div>
    <!--/ Paper overview. -->
  </div>
</section>

     <!--/ Problem Definition -->
<body>
    <h1>Problem Definition</h1>
    
    <section id="problem-definition">
       
  <p>
    Given a code model <code>M</code> and an input code snippet <code>x</code>, the class with the highest probability is the final prediction result of <code>M</code> for <code>x</code>, denoted as <code>M(x)</code>. During deployment, it is challenging to ensure that every prediction is correct. Thus, our goal is to improve model performance on test inputs via code adaptation.
</p>
<p>
    Let <code>y</code> be the ground truth label of <code>x</code> and <code>y' = M(x')</code> be the prediction result after adapting <code>x</code> to <code>x'</code> through a series of transformations.
</p>
<p>
    The objective is to compute a validation metric <code>V</code> and a set of transformations <code>T<sub>n</sub> </code> such that the loss function of the adapted prediction <code>L(y')</code> is smaller than the original loss <code>L(y)</code>.
</p>

<p>
    We aim to find <code>V</code> and <code>T</code> under the following constraints:
</p>
<ul>
    <li><code>y = M(x)</code></li>
    <li>If <code>V(M(x)) &le; c</code>, where <code>c</code> is a threshold, then:
        <ul>
            <li>Apply transformations <code>T<sub>n</sub> </code> to obtain <code>x'</code>:
                <br><code>x' = T<sub>1</sub>, T<sub>2</sub>, &hellip;, T<sub>n</sub>(x)</code>
            </li>
            <li>Predict the new input <code>x'</code> with <code>M</code> to obtain <code>y'</code>:
                <br><code>y' = M(x')</code>
            </li>
            <li>Ensure the loss of <code>y'</code> such that the new loss <code>L(y')</code> is smaller than the original loss <code>L(y)</code>:
                <br><code>L(y') &lt; L(y)</code>
            </li>
        </ul>
    </li>
</ul>
<p>
    The loss <code>L</code> is characterized by the distance from the ground truth. For example, a simple loss function could be:
</p>
<ul>
    <li>If the prediction equals the ground truth, the loss is 0: <code>L(y') = 0</code>.</li>
    <li>If the prediction does not equal the ground truth, the loss is 1: <code>L(y') = 1</code>.</li>
</ul>

<p>
    The challenge is to develop an effective validation metric <code>V</code> and a sequence of transformations <code>T<sub>n</sub> </code> that adapt mispredicted inputs, thereby improving the model's performance without necessitating retraining.
</p>
</section>
</body>

    
<section class="section">
  <div class="container is-max-desktop">
    <!-- Rules -->
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <h2 class="title is-3">Transformation Rules </h2>
        <div class="content has-text-justified">
            <ol type="1">
                <p> CodeImprove currently employs 15 transformation operators. The list of operators are as follows: <br><br></p>
              <li>Function and Variable Name Renaming</li>
                    <p>
                        We will extract all identifiers from a given input by parsing the code and capturing the identifiers by filtering out keywords, macros, and special identifiers (e.g., main, stdio, etc.). This step ensures that the identifiers are only variable/function names. 
                        <br>
                        Next, the process of renaming identifiers involves two steps: identifying and subsituting the most important identifier. 
                        
                        <br> Our approach is focused on obtaining the logit outputs by the target model for supervision. 
                        We introduce a metric called the importance score. 
                        To compute the importance score we retrieved the tokens of both original code C = [t<sub>0</sub>, · · ·, t<sub>i</sub>, · · ·] and code after replacing the identifier with [MASK] at the i<sup>th</sup> token C<sub>i</sub> = [t<sub>0</sub>, · ·, t<sub>i-1</sub>, [MASK], t<sub>i+1</sub>, · · ·]. 
                        The logit output of C and C<sub>i</sub> denoted as O<sub>y</sub>(C) and O<sub>y</sub>(C<sub>i</sub>) respectively. 
                        
                        The importance score is denoted as: <br> <br>
                        I<sub>i</sub> = O<sub>y</sub>(C) − O<sub>y</sub>(C<sub>i</sub>) <br><br>


                        Once the importance scores are computed, we select the top K identifiers. For each identifier in K we replace the original
                        identifier by generating candidates using the RoBERTa masked language model. Then we selected the identifier with highest logit output value to replace the original code. 
                        Maintaining K identifiers ensure to limit the large search space because the search space is limited to K identifiers.

                        <pre><code>
                            int i; to int t; 
                        </code></pre>

                        
                    </p>
                
              <li>for-loop to while-loop. <br>
            <pre>
            <code>
            For-loop:
                for (initialization; condition; increment) {
                // Loop body
                // Statements to execute
                }

            While-loop Transformation:
                initialization
                while (condition) {
                    // Loop body
                    // Statements to execute
                    increment;
                }
              </code>
              </pre>
              <br></li>
              <li>while-loop to for-loop. <br><br>
               <pre>
               <code>
            While-loop:
                while (condition) {
                        // Loop body
                        // Statements to execute
                        increment;
                }

            For-loop Transformation:
                for(initialization; condition; increment) {
                    // Loop body
                    // Statements to execute
                }
                </code>
                </pre>  </li>
              <li>do-loop to while-loop. <br> 
                    <p>During do-while-loop transformation into a while-loop, the body statement inside the do-while-loop
                    will be executed once before entering the transformed
                    while-loop. </p>
              <pre>
              <code>
               Do-while-loop:
                    do {
                        // Loop body
                        // Statements to execute
                        increment;
                    } while (condition);

                While-loop Transformation:
                        // Execute the loop body
                        // Statements to execute
                        while (condition) {
                        // Loop body
                        // Statements to execute
                        increment;
                    }
                    </code>
                    </pre>
              
              
              
              
              </li>
              <li>if elseif to if else <br>
              <pre>
              <code>
               if else-if :
                    if(condition A){ 
                          //body A
                    }else-if (condition B){
                          //body B
                    } else {
                          //body C
                    }

                if-else transformation:
                    if(condition A){ 
                          //body A
                    } else {
                         if (condition B) {
                            //body B
                         }
                         else {
                            //body C
                          }
                     } 
                    </code>
                    </pre>
              </li>
              <li>if else to if else-if <br> 
              <pre>
              <code>

                  if-else:
                    if(condition A){ 
                          //body A
                    } else {
                         if (condition B) {
                            //body B
                         }
                         else {
                            //body C
                          }
                     } 

                    if else-if transformation:
                      if(condition A){ 
                          //body A
                        }else-if (condition B){
                          //body B
                        } else {
                          //body C
                        }
              </code>
              </pre>
              </li>
                  
              <li>Switch statements to if elseif <br> <pre><code>
                <pre>
              <code>
                  switch statement:
                      switch (a) {
                        case A: body A
                        case B: body B
                        default: body C
                     }

                  if else-if transformation: 
                      if (a ==A) body A
                      else if (a==B) body B
                      else body C 
             
              </code>
               </pre>
              </li>
              
                    
                  
              <li>Relation expression transformation. <br>
               Transform relational expressions such as <pre><code> a < b to b >a </b></code></pre>
              
              </li>
              <li>Modification to Unary operations. <br> 
              Modify unary operations such as <pre><code> i++; to i=i+1;</code></pre>
              
              </li>
              <li>Modifications to incremental operations. <br>
              Modifies incremental operators such as <pre><code> i+=1; to i=i+1;</code></pre>
              
              </li>
              <li>Modifying constants <br> 
              Modify the constant values in expressions such as <pre><code> i = 0; to i = 10-10;</code></pre>
              
              </li>
              <li>Modifications to variable definitions. <br>
              Modifies the definitions of variables. <pre><code> 
              int b = 0; to int b; b=0;
              </code></pre>
              
              </li>
              <li>Add junk code. <br>
              <p>Adds code that will never be executed</p>
                  <pre><code>
                      before adding the junk code: 
                          if(a){
                              \\body A
                          }

                      after adding the junk code:
                          if(a){
                              \\body A
                              if (0) return 0;
                          }


                  </code></pre>
              </li>
              <li>Change order of statements in a block. <br>
                 <p> Only reorder the statements without any data- or control-dependency.</p>

                  <pre><code>
                    before reorder: 
                      a = b+10;
                      c = d+10;

                    after reorder:
                      c = d+10;
                      a = b+10;

                      
                  </code></pre>
              
              
              </li>
              <li>Deleting statements that print debugging hints and comments. <br>
                <p>Only delete comments or statements that print debugging hints or intermediate results.</p>
                 <pre><code>
                        printf("trial");
                        //comments;


                         to 

                          <strike>printf("trial); </strike>
                          <strike> //comments;  </strike>
                    

                     
                 </code></pre>
                  
              </li>

            </ol>  
     </div>
      </div>
    </div>
    <!--/ Paper overview. -->
  </div>
</section>

  <section id="Input-validation">
        <h2>Experiment Results</h2>
      <p> We show that CodeImprove's input validation outperforms exisiting techniques. We compared our technique with CLD, another approach used by leveraging the proportion to the best prediction with the next top two predictions. Also, we tried CLD with CodeImprove's equations 1-3 (shown in the paper) generating sub-models without dropout. Based on Table 1, we can conclude that CodeImprove still outperforms the other techniques in terms of AUC score.</p>
        <table>
            <caption>Table 1: AUC Comparison of Different Input Validation Techniques</caption>
            <thead>
                <tr>
                    <th rowspan="2">Experiment</th>
                    
                    <th colspan="3">Vulnerability Detection</th>
                    <th colspan="3">Defect Prediction</th>
                </tr>
                <tr>
                    <th>CodeBERT</th>
                    <th>RoBERTa</th>
                    <th>GraphCodeBERT</th>
                    <th>CodeBERT</th>
                    <th>RoBERTa</th>
                    <th>GraphCodeBERT</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>CLD</td>
                    
                    <td>0.850</td>
                    <td>0.819</td>
                    <td>0.757</td>
                    <td>0.889</td>
                    <td>0.828</td>
                    <td>0.873</td>
                </tr>
                <tr>
                    <td>CodeImprove-no-dropout</td>
                    
                    <td>0.850</td>
                    <td>0.819</td>
                    <td>0.757</td>
                    <td>0.891</td>
                    <td>0.903</td>
                    <td>0.898</td>
                </tr>
                <tr>
                    <td>CodeImprove</td>
                   
                    <td>0.876</td>
                    <td>0.825</td>
                    <td>0.781</td>
                    <td>0.911</td>
                    <td>0.924</td>
                    <td>0.909</td>
                </tr>
            </tbody>
        </table>
    </section>

    
    <section>
         <section id="examples">
        <h1>More Examples on Adapted Inputs by CodeImprove</h1>

             <p>The objective of this section is to examine whether the adapted programs maintain the semantics of the original inputs. We investigate the effectiveness of applying semantic preserving program transformations to adapt out-of-scope inputs. Based on our investigation we provide examples below</p>
        <div class="container">
            <div class="figure">
                <img src="./Example/1a.jpg" alt="Before Transformation">
                <div class="caption">
                    <p><strong>(a) Before Transformation</strong></p>
                    
                </div>
            </div>
            <div class="figure">
                <img src="./Example/1b.jpg" alt="After Transformation">
                <div class="caption">
                    <p><strong>(b) After Transformation</strong></p>
                   
                </div>
            </div>
        </div>
        <div class="section-caption">
            <p>Fig. 1: An example of a Mispredicted Input changed to a Correctly Predicted Input by CodeImrpove</p>
        </div>

             <p>In the transformation of the given code in Fig. 1, several key changes were made to improve the model's understanding of the code data. Originally (lines 10-12), variables were declared and assigned together, and the loop increment was written as i++. The increment operation within the loop was simplified to count++. After transformation (lines 10-18), variables were declared separately (int count; int i; int j;) and assigned later (cout = 0;), the loop increment was explicitly written as i = i + 1, and the increment operation was clarified to count = count + 1. These changes made the code logic more explicit, helping the model accurately predict the “wrong output”.
            </p>

        <div class="container">
            <div class="figure">
                <img src="./Example/6a.jpg" alt="Before Transformation">
                <div class="caption">
                    <p><strong>(a) Before Transformation</strong></p>
                    
                </div>
            </div>
            <div class="figure">
                <img src="./Example/6b.jpg" alt="After Transformation">
                <div class="caption">
                    <p><strong>(b) After Transformation</strong></p>
                   
                </div>
            </div>
        </div>
        <div class="section-caption">
            <p>Fig. 2: An example of a Mispredicted Input changed to a Correctly Predicted Input by CodeImrpove</p>
        </div>
    </section>

    <p>
       In the transformation of the provided code in Fig. 2, several changes were made to improve the model's prediction accuracy. Initially, in the original code (lines 6-34), the loops and condition checks were straightforward, with nested loops for scanning and processing the array.  First, the while loop in line 6 was converted to a for loop. Then, the initialization and increment of for loops lines 22 and 24 has been seperated in the Fig. 2b. At last, After transformation (lines 7-42), some for loops (lines 25, 29, 30 in Fig.2a) were converted into while loops with explicit increment operations (k++, j++), and variables were initialized separately.  These adjustments made the model to understand code logic differently, resulting in the model accurately predicting the "wrong output".
        
    </p>

    <div class="container">
            <div class="figure">
                <img src="./Example/3a.jpg" alt="Before Transformation">
                <div class="caption">
                    <p><strong>(a) Before Transformation</strong></p>
                    
                </div>
            </div>
            <div class="figure">
                <img src="./Example/3b.jpg" alt="After Transformation">
                <div class="caption">
                    <p><strong>(b) After Transformation</strong></p>
                   
                </div>
            </div>
        </div>
        <div class="section-caption">
            <p>Fig. 3: An example of a Mispredicted Input changed to a Correctly Predicted Input by CodeImrpove</p>
        </div>

        <p>
            In the code transformation in Fig. 3, key changes were made to improve the prediction accuracy by CodeImprove. Initially, the code used for loops (lines 8-9, 11-12) to iterate over the array for scanning values and finding the minimum. In the transformed version, these for loops were replaced with while loops (lines 8-11, 16-19), where the loop variables were explicitly incremented (i++) within the loop bodies. Additionally, the initialization of the loop variable i was moved outside the loops (lines 8, 16), and leading to the correct prediction of the "wrong output".
        </p>

    <div class="container">
            <div class="figure">
                <img src="./Example/4a.jpg" alt="Before Transformation">
                <div class="caption">
                    <p><strong>(a) Before Transformation</strong></p>
                    
                </div>
            </div>
            <div class="figure">
                <img src="./Example/4b.jpg" alt="After Transformation">
                <div class="caption">
                    <p><strong>(b) After Transformation</strong></p>
                   
                </div>
            </div>
        </div>
        <div class="section-caption">
            <p>Fig. 4: An example of a Mispredicted Input changed to a Correctly Predicted Input by CodeImrpove</p>
        </div>

        <p>
            In the provided code snippet in Fig. 4, several transformations were made to improve prediction accuracy. Initially (lines 3-14), the code declared the array a[100][100] and used compact for loops with combined initialization and iteration. Specifically, the loop on line 7 was used to reset t[i], and the loop on line 13 started with i = 1. After transformation (lines 3-15), the array declaration was updated with specific dimensions by modifying the constants, with expressions like i = (509 - 409) and i = (234 - 233). These changes lead to an accurate model predictions.

        </p>
    <div class="container">
            <div class="figure">
                <img src="./Example/5a.jpg" alt="Before Transformation">
                <div class="caption">
                    <p><strong>(a) Before Transformation</strong></p>
                    
                </div>
            </div>
            <div class="figure">
                <img src="./Example/5b.jpg" alt="After Transformation">
                <div class="caption">
                    <p><strong>(b) After Transformation</strong></p>
                   
                </div>
            </div>
        </div>
        <div class="section-caption">
            <p>Fig. 5: An example of a Mispredicted Input changed to a Correctly Predicted Input by CodeImrpove</p>
        </div>

        <p>
            In the provided code snippet in Fig. 5, several transformation were made to improve prediction accuracy. Initially (lines 3-16), the while loop on line 12 iterated with t-- and the base case for gcd_euclid on lines 3-7 used simple conditions. In the transformed version (lines 3-20), the while loop was replaced with a for loop (for(; t--; )), and conditions within gcd_euclid were expanded with modified constant values, such as if (b == (910 - 910)) and if (a >= b && b > (404 - 404)). These changes transformation lead to the correct prediction of the "wrong output".
        </p>
        <div class="container">
            <div class="figure">
                <img src="./Example/7a.jpg" alt="Before Transformation">
                <div class="caption">
                    <p><strong>(a) Before Transformation</strong></p>
                    
                </div>
            </div>
            <div class="figure">
                <img src="./Example/7b.jpg" alt="After Transformation">
                <div class="caption">
                    <p><strong>(b) After Transformation</strong></p>
                   
                </div>
            </div>
        </div>
        <div class="section-caption">
            <p>Fig. 6: An example of a Mispredicted Input changed to a Correctly Predicted Input by CodeImrpove</p>
        </div>
            <p>
                In the provided code snippet in Fig. 6, several transformations were made to improve prediction accuracy. Initially (lines 2-14), the while loop on line 13 iterated with a-- and the base case for GCD on line 3 used a simple condition (if (b == 0)). In the transformed version (lines 2-15), the while loop was replaced with a for loop (for (; a--; )), and the condition within GCD was expanded with modified constant values (if (b == (948 - 948))). These changes lead to the correct prediction of a "timeout error".
            </p>
        <div class="container">
            <div class="figure">
                <img src="./Example/8a.jpg" alt="Before Transformation">
                <div class="caption">
                    <p><strong>(a) Before Transformation</strong></p>
                    
                </div>
            </div>
            <div class="figure">
                <img src="./Example/8b.jpg" alt="After Transformation">
                <div class="caption">
                    <p><strong>(b) After Transformation</strong></p>
                   
                </div>
            </div>
        </div>
        <div class="section-caption">
            <p>Fig. 7: An example of a Mispredicted Input changed to a Correctly Predicted Input by CodeImrpove</p>
        </div>

        <p>
            In the provided code snippet in Fig 7, several transformation were made to improve prediction accuracy. Initially (lines 7-10), the while loop iterated with t--, and the for loop used a standard initialization and increment pattern. In the transformed version (lines 6-17), the while loop was replaced with a for loop (for(; t--; )), and the initialization for the inner for loop was separated with an increment operation (i++;). These changes lead to the correct prediction of the "wrong output".
        </p>

     <div class="container">
            <div class="figure">
                <img src="./Example/9a.jpg" alt="Before Transformation">
                <div class="caption">
                    <p><strong>(a) Before Transformation</strong></p>
                    
                </div>
            </div>
            <div class="figure">
                <img src="./Example/9b.jpg" alt="After Transformation">
                <div class="caption">
                    <p><strong>(b) After Transformation</strong></p>
                   
                </div>
            </div>
        </div>
        <div class="section-caption">
            <p>Fig. 8: An example of a Mispredicted Input changed to a Correctly Predicted Input by CodeImrpove</p>
        </div>

        <p>
            In the provided code snippet in Fig. 8, several transformation were undertaken to improve prediction accuracy. Initially (lines 2-3), variables were declared together, and the while loop (line 5) iterated with t--. In the transformed version (lines 2-7), variable declarations were separated, and the while loop was replaced with a for loop (for(; t = t-1;)). These modifications  helped the model correctly predict a "timeout error". 

        </p>

        <div class="container">
            <div class="figure">
                <img src="./Example/10a.jpg" alt="Before Transformation">
                <div class="caption">
                    <p><strong>(a) Before Transformation</strong></p>
                    
                </div>
            </div>
            <div class="figure">
                <img src="./Example/10b.jpg" alt="After Transformation">
                <div class="caption">
                    <p><strong>(b) After Transformation</strong></p>
                   
                </div>
            </div>
        </div>
        <div class="section-caption">
            <p>Fig. 9: An example of a Mispredicted Input changed to a Correctly Predicted Input by CodeImrpove</p>
        </div>

        <p>
            In the provided code snippet in Fig. 9, several transformations were made to improve prediction accuracy. Initially (lines 9-20), nested for loops were used for array operations. The outer loop on line 18 was used to decrement i, and the inner loop on line 19 iterated over j with a complex condition. In the transformed version (lines 10-33), these for loops were converted to while loops with explicit increment and decrement operations (i++, j++). This helped the model correctly predict the "wrong output".
        </p>

        <div class="container">
            <div class="figure">
                <img src="./Example/11a.jpg" alt="Before Transformation">
                <div class="caption">
                    <p><strong>(a) Before Transformation</strong></p>
                    
                </div>
            </div>
            <div class="figure">
                <img src="./Example/11b.jpg" alt="After Transformation">
                <div class="caption">
                    <p><strong>(b) After Transformation</strong></p>
                   
                </div>
            </div>
        </div>
        <div class="section-caption">
            <p>Fig. 10: An example of a Mispredicted Input changed to a Correctly Predicted Input by CodeImrpove</p>
        </div>

        <p>In the provided code snippet in Fig. 10, only one transformation was made improve prediction accuracy. Initially (lines 5-24), the while loop iterated with t--. In the transformed version (lines 5-24), the while loop was modified to decrement t  within the loop condition (t = t - 1). This change made the model correctly predict the "runtime error". 
        </p>
        
        <div class="container">
            <div class="figure">
                <img src="./Example/12a.jpg" alt="Before Transformation">
                <div class="caption">
                    <p><strong>(a) Before Transformation</strong></p>
                    
                </div>
            </div>
            <div class="figure">
                <img src="./Example/12b.jpg" alt="After Transformation">
                <div class="caption">
                    <p><strong>(b) After Transformation</strong></p>
                   
                </div>
            </div>
        </div>
        <div class="section-caption">
            <p>Fig. 11: An example of a Mispredicted Input changed to a Correctly Predicted Input by CodeImrpove</p>
        </div>

        <p>
            In the provided code snippet in Figure 11, several transformations were made to improve prediction accuracy. Initially (lines 2-10, 19-25), the gcd function used a straightforward condition (if (a == 0)) and the lcm function checked for g == 1. In the transformed version (lines 2-10, 19-25), these conditions were replaced with more explicit expressions (if (!(0 != a)) and if (g == (913 - 912))). These changes made the model correctly predict "no defects". 
        </p>

         <div class="container">
            <div class="figure">
                <img src="./Example/13a.jpg" alt="Before Transformation">
                <div class="caption">
                    <p><strong>(a) Before Transformation</strong></p>
                    
                </div>
            </div>
            <div class="figure">
                <img src="./Example/13b.jpg" alt="After Transformation">
                <div class="caption">
                    <p><strong>(b) After Transformation</strong></p>
                   
                </div>
            </div>
        </div>
        <div class="section-caption">
            <p>Fig. 12: An example of a Mispredicted Input changed to a Correctly Predicted Input by CodeImrpove</p>
        </div>

        <p>
            In the provided code snippet in Fig. 12, several transformations were made to improve prediction accuracy. Initially (lines 9-24), variables were declared with specific initial values, and nested for loops were used for array operations. The min variable was initialized to 999999, and the outer loop on line 17 iterated with c++. In the transformed version (lines 9-32), the initial values for variables were changed to expressions like (1000267 - 268) for min and (451 - 451) for c. The nested for loops were converted to while loops with  increment operations (i = i + (410 - 409)). These changes  model correctly predict the "wrong output".
        </p>

        <div class="container">
            <div class="figure">
                <img src="./Example/14a.jpg" alt="Before Transformation">
                <div class="caption">
                    <p><strong>(a) Before Transformation</strong></p>
                    
                </div>
            </div>
            <div class="figure">
                <img src="./Example/14b.jpg" alt="After Transformation">
                <div class="caption">
                    <p><strong>(b) After Transformation</strong></p>
                   
                </div>
            </div>
        </div>
        <div class="section-caption">
            <p>Fig. 13: An example of a Mispredicted Input changed to a Correctly Predicted Input by CodeImrpove</p>
        </div>

        <p>
            In the provided code snippet in Fig. 14, several transformations were made to improve prediction accuracy. Initially (lines 5-18), the while loop iterated with t-- and declared multiple variables within the loop. The while loop on line 18 checked remainder != 0. In the transformed version (lines 5-30), the while loop was replaced with a for loop (for(; t--; )), and variable declarations were separated. The second while loop was also replaced with a for loop (for(; remainder != 0; )). These changes  helped the model correctly predict the "wrong output".
        </p>
        
        <div class="container">
            <div class="figure">
                <img src="./Example/2a.jpg" alt="Before Transformation">
                <div class="caption">
                    <p><strong>(a) Before Transformation</strong></p>
                    
                </div>
            </div>
            <div class="figure">
                <img src="./Example/2b.jpg" alt="After Transformation">
                <div class="caption">
                    <p><strong>(b) After Transformation</strong></p>
                   
                </div>
            </div>
        </div>
        <div class="section-caption">
            <p>Fig. 14: An example of a Mispredicted Input changed to a Correctly Predicted Input by CodeImrpove</p>
        </div>

        <p>
            In the provided code in Fig. 14, several transformation were undertaken by CodeImprove to improve prediction accuracy. Initially (lines 2-3, 6-8, 10-14), variables were declared together, loop initializations were concise, and the sum and pos variables were reset within nested loops. After transformation (lines 2-33), variable initializations were updated with modified constants, loops were adjusted (e.g., k = k + 1, i = i + 1), and constants were added to initialization. These changes lead to the correct prediction of a "timeout error".
        </p>
    
</html>
